---
title: PCL入门《五》使用VOXEL稀疏点云
date: 2020-02-08 15:19:05
tags:
---
在使用PCL的处理点云时，很多时候我们不需要有太过高的分辨率，因为点云过多会造成计算变慢，并且更加消耗计算资源，所以我们需要把点云变稀，voxel就是一个很好的方法。

voxel就是三维的pixel，也就是把点云画出网格，然后每个网格内保留一个点就可以了。网格的大小可以自己定义，这就相当于一个downsample（下采样）

![]()![](1.png)  

大概的样子就是这样，我显示出了所有的点，如果某一个格子内没有点就可以不显示了，你也可以把格子调的很密，颜色也可以保留。

话不多说，直接上代码：

首先必要的引用的是

    
    
    #include <pcl/io/pcd_io.h>
    #include <pcl/point_types.h>
    #include <pcl/filters/voxel_grid.h>

  
其中特殊的也就是第三个了，前两个要用PCL项目的话基本上都会引用了。第三个引用了就可以使用PCL自带的voxel的功能了，不过如果不太信任pcl的筛选方法也可以自己写一个，voxel的原理很简单，就是遍历塞进不同的格子里，实现起来也就不怎么难了，我们这里只讲怎么使用pcl的方法，毕竟这样实现起来最快。

接下来的核心代码：

    
    
      pcl::VoxelGrid<pcl::PCLPointCloud2> sor;
      sor.setInputCloud (cloud);
      sor.setLeafSize (0.01f, 0.01f, 0.01f);
      sor.filter (*cloud_filtered);

  
pcl的一贯规则，你要使用voxel功能，首先需要创建一个voxel类的一个对象，也就是sor

然后输入需要过滤的点云，也就是cloud

然后设置一下叶子大小，也就是resolution（分辨率），也就是这个格子的最小间距，设置的越小则越密集，保留的点越多。三个参数分别是xyz

然后给一个输出的点云用来接收过滤的结果，最后那个cloud_filtered就是变稀疏后的cloud了，你可以看看，很有可能点数减少了十倍，但是形状还保留，基本上没什么太大的影响，不过如果你要做精确的体积估计的话这个肯定是不可以的，因为边缘肯定会变短，但是不那么精确，知道大致形状，知道中心就可以的需求就可以放心大胆的使用这个功能了。

![]()![](3.png)  

这个是官方给出的效果图，左右是过滤前后的对比，可以看到右边的图我们依然能够清晰的看出来是一张桌子上面放了个杯子，但是点明显变稀疏了，如果你觉得这种效果能够满足你的要求且不会破坏你的结果那么就可以尝试读入点云就用这个过滤一遍，点云少了后续的处理速度会快的很多。

