---
title: python创建grpc通信demo解析
date: 2020-01-07 19:12:08
tags: [python, grpc]
categories: 
- grpc
---
首先grpc使用protobuf来定义数据以及函数结构，所以需要先安装protobuf 和grpc（这里使用豆瓣云加速）
```
sudo pip install protobuf -i http://pypi.douban.com/simple
sudo pip install grpcio-tools -i http://pypi.douban.com/simple
```

然后创建一个proto文件，来看看我的例子，我要做一个识别的类，里面有一个函数叫做注册，输入参数是路径的列表和人名，返回参数是特征列表，来看看我的定义文件
```
syntax = "proto3";

option java_multiple_files = true;
option java_package = "io.grpc.examples.helloworld";
option java_outer_classname = "HelloWorldProto";
option objc_class_prefix = "HLW";

package faceserver;

service Recognition {
  // Sends a greeting
  rpc registration (Request) returns (Reply) {}
}

message Request {
  repeated string path_list = 1;
  string name = 2;
}
message Reply {
  repeated string feature_id_list = 1;
}
```

现在来解析一下，前面五行文字都直接复制，属于最基本的定义，我是从helloworld的example抄过来的，所以还能看到helloworld的痕迹，由于刚刚学会就来记录了，所以暂时还没研究把这个删掉会怎么样。第一行定义使用proto3的格式

重点在后面，package就是相当于这个项目的名字了，改成自己要的。

service是类的名字，我的类是Recognition，里面有一个函数，叫做registration，他有一个参数，是Request类型的（Request其实是个类，名字是我自己定的，你也可以叫dog, cat之类的，返回值是Reply类型的（也是我自己定义的一个类））

然后message那里是详细介绍我定义的那两个类，其中Request有两个成员变量，一个是path_list，是一个字符串数组（repeated）代表数组，还有一个是name，是一个字符串类型，等于号右边相当于一个id，只要不重复就行了。

然后定义返回值Reply这个类，它只有一个成员变量，叫做feature_id_list，也是一个字符串数组，其实我是想做成数字类型的数组，但是目前看起来它不支持int，所以先都用string表示了。

这个proto文件定义完了之后就可以生成python的类文件了，执行命令
```
python -m grpc_tools.protoc -I./ --python_out=. --grpc_python_out=. faceserver.proto 
```
faceserver.proto就是我这个proto文件的名字，执行完这一句之后就生成了两个文件
```
faceserver_pb2_grpc.pyc
faceserver_pb2.py
faceserver_pb_grpc.py
```
```
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
import grpc

import faceserver_pb2 as faceserver__pb2


class RecognitionStub(object):
  # missing associated documentation comment in .proto file
  pass

  def __init__(self, channel):
    """Constructor.

    Args:
      channel: A grpc.Channel.
    """
    self.registration = channel.unary_unary(
        '/faceserver.Recognition/registration',
        request_serializer=faceserver__pb2.Request.SerializeToString,
        response_deserializer=faceserver__pb2.Reply.FromString,
        )


class RecognitionServicer(object):
  # missing associated documentation comment in .proto file
  pass

  def registration(self, request, context):
    """Sends a greeting
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')


def add_RecognitionServicer_to_server(servicer, server):
  rpc_method_handlers = {
      'registration': grpc.unary_unary_rpc_method_handler(
          servicer.registration,
          request_deserializer=faceserver__pb2.Request.FromString,
          response_serializer=faceserver__pb2.Reply.SerializeToString,
      ),
  }
  generic_handler = grpc.method_handlers_generic_handler(
      'faceserver.Recognition', rpc_method_handlers)
  server.add_generic_rpc_handlers((generic_handler,))

faceserver_pb2.py

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: faceserver.proto

import sys
_b=sys.version_info[0]<3 and (lambda x:x) or (lambda x:x.encode('latin1'))
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor.FileDescriptor(
  name='faceserver.proto',
  package='faceserver',
  syntax='proto3',
  serialized_options=_b('\n\033io.grpc.examples.helloworldB\017HelloWorldProtoP\001\242\002\003HLW'),
  serialized_pb=_b('\n\x10\x66\x61\x63\x65server.proto\x12\nfaceserver\"*\n\x07Request\x12\x11\n\tpath_list\x18\x01 \x03(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\" \n\x05Reply\x12\x17\n\x0f\x66\x65\x61ture_id_list\x18\x01 \x03(\t2G\n\x0bRecognition\x12\x38\n\x0cregistration\x12\x13.faceserver.Request\x1a\x11.faceserver.Reply\"\x00\x42\x36\n\x1bio.grpc.examples.helloworldB\x0fHelloWorldProtoP\x01\xa2\x02\x03HLWb\x06proto3')
)




_REQUEST = _descriptor.Descriptor(
  name='Request',
  full_name='faceserver.Request',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='path_list', full_name='faceserver.Request.path_list', index=0,
      number=1, type=9, cpp_type=9, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      serialized_options=None, file=DESCRIPTOR),
    _descriptor.FieldDescriptor(
      name='name', full_name='faceserver.Request.name', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      serialized_options=None, file=DESCRIPTOR),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  serialized_options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=32,
  serialized_end=74,
)


_REPLY = _descriptor.Descriptor(
  name='Reply',
  full_name='faceserver.Reply',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='feature_id_list', full_name='faceserver.Reply.feature_id_list', index=0,
      number=1, type=9, cpp_type=9, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      serialized_options=None, file=DESCRIPTOR),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  serialized_options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=76,
  serialized_end=108,
)

DESCRIPTOR.message_types_by_name['Request'] = _REQUEST
DESCRIPTOR.message_types_by_name['Reply'] = _REPLY
_sym_db.RegisterFileDescriptor(DESCRIPTOR)

Request = _reflection.GeneratedProtocolMessageType('Request', (_message.Message,), dict(
  DESCRIPTOR = _REQUEST,
  __module__ = 'faceserver_pb2'
  # @@protoc_insertion_point(class_scope:faceserver.Request)
  ))
_sym_db.RegisterMessage(Request)

Reply = _reflection.GeneratedProtocolMessageType('Reply', (_message.Message,), dict(
  DESCRIPTOR = _REPLY,
  __module__ = 'faceserver_pb2'
  # @@protoc_insertion_point(class_scope:faceserver.Reply)
  ))
_sym_db.RegisterMessage(Reply)


DESCRIPTOR._options = None

_RECOGNITION = _descriptor.ServiceDescriptor(
  name='Recognition',
  full_name='faceserver.Recognition',
  file=DESCRIPTOR,
  index=0,
  serialized_options=None,
  serialized_start=110,
  serialized_end=181,
  methods=[
  _descriptor.MethodDescriptor(
    name='registration',
    full_name='faceserver.Recognition.registration',
    index=0,
    containing_service=None,
    input_type=_REQUEST,
    output_type=_REPLY,
    serialized_options=None,
  ),
])
_sym_db.RegisterServiceDescriptor(_RECOGNITION)

DESCRIPTOR.services_by_name['Recognition'] = _RECOGNITION

# @@protoc_insertion_point(module_scope)
```
这两个是生成的类和类型的python文件了，然后我们先写服务器

创建一个faceserver.py的文件
```
from concurrent import futures
import grpc
import faceserver_pb2
import faceserver_pb2_grpc

import time


class Recognition(faceserver_pb2_grpc.RecognitionServicer):
	# def registration(path_list, name):
	def registration(self, args, context):
		print 'path_list'
		print (args.path_list[0])
		print 'name'
		print args.name
		idx = range(len(args.path_list))
		print 'idx'
		print idx
		return faceserver_pb2.Reply(feature_id_list = map(str,idx))
def serve():
	server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
	faceserver_pb2_grpc.add_RecognitionServicer_to_server(Recognition(), server)
	server.add_insecure_port('[::]:50052')
	server.start()
	try:
	    while True:
	        time.sleep(1000)
	except KeyboardInterrupt:
	    server.stop(0)


if __name__ == '__main__':
    serve()
```
注意引用刚才生成的那两个文件，我们来看详细实现

首先服务器里面创建刚才指定的类Recognition，括号里面的内容在faceserver_pb2_grpc.py这个文件里可以看到
```
class RecognitionServicer(object):
  # missing associated documentation comment in .proto file
  pass

  def registration(self, request, context):
    """Sends a greeting
    """
    context.set_code(grpc.StatusCode.UNIMPLEMENTED)
    context.set_details('Method not implemented!')
    raise NotImplementedError('Method not implemented!')
```
有一个这个类，我们继承它就可以了，把这个名字复制到括号里面，另一个类Stub是给客户端用的，我们就不管他。

然后实现registration这个函数，在这里面可以实现内容，第二个参数就是Request类，所以path_list是他的成员变量，需要用args.path_list来获取，记得这里面的打印是服务器端的，在客户端是看不见的，要执行的也是在服务器的命令行打出来。

然后balabala了一堆过程，返回一个list，由于是string的list，所以我还用了个map函数把它从int转string，注意返回的是Reply类型，所以不要直接把python的变量放进去了，所以实际return的要转换成faceserver_pb2.Reply()这个的对象，把那一个参数放进去就可以了。

数据结构定义好了，接下来就是启动服务了，
```
server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
faceserver_pb2_grpc.add_RecognitionServicer_to_server(Recognition(), server)
server.add_insecure_port('[::]:50052')
server.start()
```
这里第一行照着抄不管他，第二行注意要注册刚刚实现的那个类，还有第一行生成的服务对象，把他们绑定到一起。第三行指定一个端口，然后就可以start了。

这里start不是阻塞的，所以后面一定要干点什么，不然程序结束了就结束了。

所以我写了一个死循环哈哈。

好了，服务器搭建完了，接下来讲客户端
```
import grpc
import faceserver_pb2
import faceserver_pb2_grpc

def run():
    with grpc.insecure_channel('localhost:50052') as channel:
        stub = faceserver_pb2_grpc.RecognitionStub(channel)
        response = stub.registration(faceserver_pb2.Request(path_list = ['aa', 'bb'], name = 'zz'))
    print response

if __name__ == '__main__':
    run()
```
客户端就简单多了，只有几句话，
```
with grpc.insecure_channel('localhost:50052') as channel:
```
这里制定以下服务器ip和端口，照着抄就行了，然后创建一个对象，就是我刚说的，在pb2_grpc这个文件里的另一个类，把它抄过来，然后执行它的函数registration，输入参数记住，虽然理论上是两个，但是实际上我们是封装到了Request类里面，所以实际上要传的是Request类，所以里面转换一下，一个path_list列表，一个name的字符，返回结果就是Reply类的对象了，里面有一个成员变量feature_list_id，这样就大功告成了