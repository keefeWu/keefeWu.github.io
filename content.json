{"meta":{"title":"Hexo","subtitle":"","description":"","author":"keefe","url":"http://blog.357573.com","root":"/"},"pages":[{"title":"tags","date":"2020-01-02T09:04:19.000Z","updated":"2020-01-02T09:11:55.630Z","comments":true,"path":"tags/index.html","permalink":"http://blog.357573.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"目标检测-RCNN","slug":"目标检测-RCNN","date":"2020-01-02T07:31:39.000Z","updated":"2020-01-02T09:17:07.078Z","comments":true,"path":"2020/01/02/目标检测-RCNN/","link":"","permalink":"http://blog.357573.com/2020/01/02/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B-RCNN/","excerpt":"","text":"rcnn首先会做一个region proposal，也就是任意的找到一些疑似完整物体的区域，这一步是任意的，根据梯度信息找到一些边缘，然后就圈出来了。这一步会找到非常多的区域作为候选框，给接下来的分类提供素材。论文说的是找了两千多个 接着把那些候选框一个一个输入神经网络，算出特征。 接着把算出的特征交给svm去做分类，得到分类与置信度。 最后每个类别在训练出四个向量，保证预测的时候特征*这四个向量可以得到x,y,w,h，这样坐标的缩放和偏移量也就算出来了。 所谓的候选区域推荐其实就是根据梯度信息找到一些边界，然后选出一个个疑似完整的物体。 而RCNN的region proposal用的是selective search的方法，这种方法说来也简单，就是每两个相邻区域计算相似度。 如果相似度大于阈值就合并，接着循环，直到不能再合并为止。而一开始是每个像素点为一个区域所以这个过程就是由点逐步变大的过程。 这一步做完了，图中就会出现很多的候选框，然后每个候选框经过神经网络，算出特征。 他这个网络就用的是alexnet，模型也直接拿的imagenet上训练好了的，这样他就不需要从头训练，只需要对输出类别进行一下finetune就行了。由于alexnet输入是固定的227*227的，所以刚才region proposal出来的每一个候选框都resize成227*227输入到这个网络中，算出4096维的特征。注意啊，这个图上是224的，实际上是错误的，因为和alexnet论文下面自相矛盾了，他下面输出是55，而步长是4，核大小是11，所以输入必须是227才能被整除。因为我们这一步只需要提取特征，而alexnet是为了在imagenet上进行分类，所以最后又加了一层1000维的全连接，是因为imagenet是有1000个分类，所以弄了1000维的全连接加上softmax，我们这一步只需要提取特征，就不需要softmax了，所以我们这一步得到的结果是每个候选框算出一个4096维的特征，假设有n个候选框就会算出n个4096维的特征。 而实际上论文也说了，这个n就是2000左右，我们会找两千个左右的区域。所以最后经过CNN会出现2000个4096维的特征向量。 这个神经网络训练的时候加了一层21维的全连接层以及softmax，因为PASCAL VOC比赛要求的是20种分类，那么加上背景就是21种了。这里我们可以根据自己的需要任意改变这个输出种类。他在训练的时候每个区域判断和groundtruth的IOU，就是交集比上并集，如果IOU&gt;0.5就认为是相应的物体，小于就当做背景。然后学习率设的很小，只有0.001，因为是finetune的，每次迭代选了32个正样本，96个背景作为一个batch去训练。 最后拿着这些特征去训练SVM，SVM训练时候也是有讲究的，他的正样本直接取的是groundtruth了，而负样本采用的是IOU&lt;0.3的proposal，中间的全部扔掉。 为什么要扔掉呢？他后面也写了，因为这个候选情况太多了，我们选择最有代表的样例就行了，不然的话因为允许有偏差，正样例数量可能会扩大30倍 也就是因为训练CNN时候用的正样本是IOU&gt;0.5的，背景是IOU&lt;0.5。而训练SVM的时候正样本就是IOU=1的，负样本是IOU&lt;0.3的，就是这里对位置要求的严格，使得分类的准确率大大提升，所以最终选择使用加一步SVM的分类，而不是直接采用softmax进行分类。 分类结果出来以后就该算出准确位置了，因为这些候选框都是一开始第一步粗略挑选出来的，期初他并不知道类别，所以位置和大小也并不一定准确，所以接下来要找到这个框的精确位置。我们说精确位置，其实包含了框的位置和大小，所以我们要得到的也就是4个数字，分别是deltax，deltay，wscale，hscale，分别表示真实边框相对于预测的这个框左上角顶点偏移量，以及长宽的放大尺度。这四个值其实是能够根据特征学习出来的。因为我们上一层也就是CNN输出的是4096维的特征，这一层要输出的是4个数，假设我们有4个4096维的向量，和那4096维的特征相乘，假设特征是1行，4096列，而这个向量是4096行1列，那么乘出来就是1个数了。把这个数当做deltax，那么那个向量就是deltax的参数了，同样的道理，每个类别求出4个这样的向量，分别就是deltax，deltay，wscale，hscale的参数向量了。这个向量明显是可以学习的出来的，因为不同的特征代表物体不同区域，其实是有规律可循的，所以这个变换的向量也就一定可以学习的出来的。这个学习的过程其实就是边框回归。 回归训练的时候一定要用IOU&gt;0.6的样本训练，太小了实在很难看出是什么，对于这种简单的线性参数干扰很大，所以这一步其实只适合用来微调，训练的时候一定要控制好IOU。 总结 有了这几步，RCNN的全部流程就出来了，先用selective search找到2000个region proposal，再用finetune过的alexnet算出2000个4096维的特征，分别计算这2000个对应的类别和置信度，然后用bbox regression去回归他准确的位置。","categories":[{"name":"论文解读","slug":"论文解读","permalink":"http://blog.357573.com/categories/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"}],"tags":[{"name":"目标检测","slug":"目标检测","permalink":"http://blog.357573.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"论文解读","slug":"论文解读","permalink":"http://blog.357573.com/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"},{"name":"RCNN","slug":"RCNN","permalink":"http://blog.357573.com/tags/RCNN/"},{"name":"算法","slug":"算法","permalink":"http://blog.357573.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"图像处理","slug":"图像处理","permalink":"http://blog.357573.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-02T00:23:48.697Z","updated":"2020-01-02T00:23:48.697Z","comments":true,"path":"2020/01/02/hello-world/","link":"","permalink":"http://blog.357573.com/2020/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"hexo 博客搭建","slug":"hexo-博客搭建","date":"2020-01-01T02:42:40.000Z","updated":"2020-01-02T07:23:39.894Z","comments":true,"path":"2020/01/01/hexo-博客搭建/","link":"","permalink":"http://blog.357573.com/2020/01/01/hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"备份因为hexo提交到git上只有生成的html文件，没有源码文件，导致一旦换了电脑就直接gg了，所以我找了一个插件GitHub 使用方法npm install hexo-git-backup --save 在_config.yml中添加一项backup:&emsp;&emsp;type: git&emsp;&emsp;repository:&emsp;&emsp;&emsp;&emsp;github: git@github.com:xxx/xxx.git,branchName之后每次用hexo b就可以备份上传了注意一点，这里的分支一定要和master分支区分开，master就专门用来存放网站的，源码放在另一个分支上，可以新建一个source分支，然后把source分支设置成主分支，这样的话下次你git clone就可以直接clone代码了。 远程配置这玩意自动关联的git，所以需要设置一下，也是在_config.yml中，它本来就有deploy,所以补充一下就行了deploy:&emsp;&emsp;type: git&emsp;&emsp;repo: git@github.com:xxx/xxx.git&emsp;&emsp;branch: master之后使用hexo d就是上传到git了，不过也需要安装一个插件npm install hexo-deployer-git --save 基础操作以上配置好了之后实际上就可以用了，如果要新建文章则使用hexo new 文章名,注意这里文章名如果有空格的话记得用斜杠转译，就像我这篇文章的标题一样，是用的 hexo new hexo\\ 博客搭建新建好的文件在source这个目录里，其实你输入了new之后命令行打印出来了文件路径，就是那个md文件，markdown格式的，去了修改就行了。写好之后渲染成html的，使用hexo g也就是generator渲染，如果要本地测试的话就是hexo s，开启一个server，提交到git就用hexo d deploy，上传源码就使用hexo b backup hexo环境搭建我把这个放到最后，是因为这个的资料太多了，前面几个都是我个人总结的，比较难查到的，这个是想着做事做到尽善尽美才加上的。首先下载nodejs，因为hexo是用node写的，地址在https://nodejs.org/en/解压之后把这些放到/usr/local下面就行了然后node的安装源可以换成国内的加速npm config set registry https://registry.npm.taobao.org当然，这个很显然是可有可无的然后是安装hexo了npm i hexo-cli -g这样就算部署完毕了 更换主题这个我觉得挺重要，默认的那个landscape的主题确实太土了，所以可以去主题仓库找找看https://hexo.io/themes/ 找到满意的之后进入theme目录，然后把主题clone下来比方说我这个主题git clone https://github.com/fi3ework/hexo-theme-archer.git下好之后在_config.yml中配置一下theme，就是目录名就可以了。 统计访问量我这个主题是自带统计访问量的，但是需要安装一个插件，所以需要执行npm i --save hexo-wordcount然后修改在 archer 的配置中的reading_info: true不过busuanzi这个js偷偷的把pv、uv的内容隐藏了，就是加上了“display: none;”属性，我在网上看见有人说需要人工去打开，就是在这个主题的css里，我这个主题是在_intro.scss文件里面，加上了 1234567891011121314#busuanzi_container_site_pv &#123; &#x2F;* 网站页脚访问pv *&#x2F; display: inline !important;&#125;#busuanzi_container_site_uv &#123; &#x2F;* 网站页脚访问uv *&#x2F; display: inline !important;&#125;#busuanzi_container_page_pv &#123; &#x2F;* 文章访问pv *&#x2F; display: inline !important;&#125; 但是呢。我这个加了还是有，没办法，我只好去 “base-footer.ejs”文件里面把pv的id去掉，变成 12345678&lt;% if(theme.busuanzi_pv_or_uv &#x3D;&#x3D;&#x3D; &#39;pv&#39;) &#123; %&gt; &lt;span&gt;&lt;%- sloganPieces[0] %&gt;&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;&lt;%- sloganPieces[1] %&gt;&lt;&#x2F;span&gt; &lt;% &#125; else if (theme.busuanzi_pv_or_uv &#x3D;&#x3D;&#x3D; &#39;uv&#39;) &#123; %&gt; &lt;span&gt;&lt;%- sloganPieces[0] %&gt;&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;&lt;%- sloganPieces[1] %&gt;&lt;&#x2F;span&gt; &lt;% &#125; %&gt; &lt;&#x2F;div&gt; &lt;% &#125; %&gt; &lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;","categories":[],"tags":[]}]}